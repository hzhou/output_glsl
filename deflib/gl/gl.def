include: gl/glfw.def
include: gl/gl_timing.def
include: gl/gl_geometry.def
subcode: gl_frame
    $include stdio
    $include stdlib
    $call gl_require
    $list gl_main

#----------------------------------------------- 
fncode: gl_main(main)
    $call glfw_init

    glEnable(GL_DEPTH_TEST)
    glDepthFunc(GL_LESS)
    glClearColor(0, 0, 0.4, 0.0)

    $call @load_program, program_0
    DUMP_STUB _setup
    $call @init_systime
    $while 1
        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
        glUseProgram(program_0)
        $call @set_uniform_list
        $Call main2
        DUMP_STUB _draw

        glfwSwapBuffers(win)
        $call check_fps

        glfwPollEvents()
        $if glfwGetKey(win, GLFW_KEY_ESCAPE)==GLFW_PRESS
            goto Finish
        $if glfwWindowShouldClose(win)
            goto Finish

    DUMP_STUB _cleanup
    Finish:
    glfwTerminate()
    $print

    return 0

#----- shader programs ------
subcode: load_program(v_prog)
    $local GLuint $(v_prog)
    $(if:shader_string)
        $global s_vsrc=[file:$(shader).vsl]
        $global s_fsrc=[file:$(shader).fsl]
    $(else)
        s_vsrc = get_file_s("$(shader).vsl", NULL)
        s_fsrc = get_file_s("$(shader).fsl", NULL)
    $(v_prog) = load_shaders(s_vsrc, s_fsrc)
    $(block:_cleanup)
        glDeleteProgram($(v_prog))

fncode: load_shaders(s_vsrc, s_fsrc)
    $call load_shader, VERTEX, s_vsrc
    $call load_shader, FRAGMENT, s_fsrc
    $local GLuint program
    program = glCreateProgram()
    glAttachShader(program, shader_VERTEX)
    glAttachShader(program, shader_FRAGMENT)
    $print Linking shader program ...
    glLinkProgram(program)
    $call showinfo, program, Program, GL_LINK_STATUS
    $(for:VERTEX,FRAGMENT)
        glDetachShader(program, shader_$1)
        glDeleteShader(shader_$1)
    return program

    subcode: load_shader(type, src)
        # type: VERTEX or FRAGMENT
        $(set:V=shader_$(type))
        $local GLuint $(V)
        $(V) = glCreateShader(GL_$(type)_SHADER)
        $if $(src)
            $(set:C=const char *const *)
            glShaderSource($(V), 1, ($(C))&$(src), NULL)
            $print Compiling shader_$(type) ...
            glCompileShader($(V))
            $call showinfo, $(V), Shader, GL_COMPILE_STATUS
        $else
            $print "Null $(src)"
            return 0

    subcode: showinfo(V, type, status)
        $my GLint Result, tn_info_len, ts_info
        glGet$(type)iv($(V), $(status), &Result)
        glGet$(type)iv($(V), GL_INFO_LOG_LENGTH, &tn_info_len)
        $if tn_info_len>0
            $allocate(tn_info_len+1) ts_info
            glGet$(type)InfoLog($(V), tn_info_len, NULL, ts_info)
            puts(ts_info)

#---------------------------------------- 
subcode: set_uniform_list
    $(if:uniform_list)
        $local GLint loc
        $(for:v in $(uniform_list))
            loc = glGetUniformLocation(program_0, "$(v)")
            $if loc!=-1
                $call set_uniform_$(v)

subcode: set_uniform_n_width
    glUniform1i(loc, n_width)

subcode: set_uniform_n_height
    glUniform1i(loc, n_height)

